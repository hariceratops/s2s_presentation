<!-- https://github.com/gnab/remark/issues/538#issuecomment-419173985 -->
<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Rubik);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700,400italic);

      body { font-family: 'Rubik'; }
      h1 {
        font-family: 'Rubik';
        font-weight: bold;
      }
      h2, h3 {
        font-family: 'Rubik';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Source Code Pro'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Binary Parsing, C++23 Style
### Hari Prasad Manoharan

---
### About Me

```bash
> whoami
USER:hari
COMPANY:mbition
GIT:https://github.com/hariceratops/
LINKEDIN:https://www.linkedin.com/in/hari-prasad-manoharan-79a4ba102/
PRIMARY_DOMAIN:embedded_systems
ENGINEER_SINCE:2016_08_16
```
---
### Disclaimer

- I am not an expert, I am just a dude
- The views presented are not of my employer
- Project is not production ready, at least not yet!
- We will walkthrough the simplified version of the project source
---
### How this came to be?
- Parsing binary format is something any developer would run into at some point
- No declarative way to describe a binary format in C++
- Came across
  - [CTRE, Hana Dusíková](https://www.youtube.com/watch?v=g51_HYn_CqE&t=1232s)
  - [namedtuple++, Kris Jusiak](https://www.youtube.com/watch?v=4PwNi0Zgmm0)
  - [Value Based Metaprogramming, Kris Jusiak](https://www.youtube.com/watch?v=yriNqhv-oM0)
???
- Attend conferences
---
class: center, middle
# Fact Check!
---
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};
auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance), sizeof(instance));
  std::println("{:X} {:X} {:X}", 
    instance.member_1, 
    instance.member_2, 
    instance.member_3
  );
};
```
```sh
# Input: file.bin
0x000000: 0xef 0xbe 0xad 0xde ....
0x000004: 0x0d 0xd0 0xfe 0xca ....
0x000008: 0xef 0xbe 0xef 0xbe ....
0x00000c:
   bytes: 12
```
--
count: false
```sh
deadbeef cafed00d beefbeef
```
---
```cpp
struct some_thing {
  uint32_t member_1;
* uint8_t member_2;
  uint32_t member_3;
};
auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance), sizeof(instance));
  std::println("{:X} {:X} {:X}", 
    instance.member_1, 
    instance.member_2,
    instance.member_3
  );
};
```
```sh
# Input: file.bin
0x000000: 0xef 0xbe 0xad 0xde ....
*0x000004: 0x2a 0x0d 0xd0 0xfe ....
0x000008: 0xca                ....
0x00000c:
   bytes: 9
```
--
count: false
```sh
deadbeef 2a ca7f
```
---
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};

auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance), sizeof(instance));
  std::println("{:X} {:X} {:X}", 
    instance.member_1, 
    instance.member_2, 
    instance.member_3
  );
};
```
```sh
0x000000: 0xef 0xbe 0xad 0xde ....
*0x000004: 0x42 0x42 0x42 0x0d ....
0x000008: 0xd0 0xfe 0xca      ....
0x00000c:
   bytes: 11
```
--
count: false
```sh
deadbeef d424242 c9cafed0
```
---
Solution
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};

auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;          
  file.read(reinterpret_cast<char*>(&instance.member_1), sizeof(instance.member_1));
  file.read(reinterpret_cast<char*>(&instance.member_2), 3);
  file.read(reinterpret_cast<char*>(&instance.member_3), sizeof(instance.member_3));
  std::println("{:X} {:X} {:X}", instance.member_1, instance.member_2, instance.member_3);
  file.close();
};
```
---
count: false
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};

auto parse_something(std::ifstream& file) -> some_thing {
  constexpr std::size_t member_1_size = sizeof(instance.member_1);
  constexpr std::size_t member_2_size = 3;
  constexpr std::size_t member_3_size = sizeof(instance.member_3);

  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance.member_1), member_1_size);
  file.read(reinterpret_cast<char*>(&instance.member_2), member_2_size);
  file.read(reinterpret_cast<char*>(&instance.member_3), member_3_size);
  return instance;
}

auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance = parse_something();          
  std::println("{:X} {:X} {:X}",
    instance.member_1, 
    instance.member_2, 
    instance.member_3
  );
  file.close();
};
```
---
Lets throw this to our code
```sh
0x000000: 0xef 0xbe 0xad 0xde ....
0x000004: 0x42 0x42 0x42 0x0d ....
0x000008:                     ....
0x00000c:
   bytes: 8
```
--
count: false
We will have to handle buffer exhaustion now
--
count: false
```cpp
enum parse_error { buffer_exhausted = 0 };
using parse_res = std::expected<some_thing, parse_error>;

auto parse_something(std::ifstream& file) -> parse_res {
  constexpr std::size_t member_1_size = sizeof(instance.member_1);
  constexpr std::size_t member_2_size = 3;
  constexpr std::size_t member_3_size = sizeof(instance.member_3);

  some_thing instance;
  if(!file.read(reinterpret_cast<char*>(&instance.member_1), member_1_size))
    return std::unexpected(parse_error::buffer_exhausted);
  if(!file.read(reinterpret_cast<char*>(&instance.member_2), member_2_size))
    return std::unexpected(parse_error::buffer_exhausted);
  if(!file.read(reinterpret_cast<char*>(&instance.member_3), member_3_size))
    return std::unexpected(parse_error::buffer_exhausted);
  return instance;
}
```
---
```cpp
struct some_thing {
  uint32_t member_1;
  bool member_2;
  // Has to be parsed only if member_2 == true
  uint32_t member_3;
};
```
--
count: false
```cpp
auto parse_something(std::ifstream& file) -> parse_res {
  constexpr std::size_t member_1_size = sizeof(instance.member_1);
  constexpr std::size_t member_2_size = 3;
  constexpr std::size_t member_3_size = sizeof(instance.member_3);

  some_thing instance;
  if(!file.read(reinterpret_cast<char*>(&instance.member_1), member_1_size))
    return std::unexpected(parse_error::buffer_exhausted);
* if(instance.member_2 && !file.read(reinterpret_cast<char*>(&instance.member_2), member_2_size))
    return std::unexpected(parse_error::buffer_exhausted);
  if(!file.read(reinterpret_cast<char*>(&instance.member_3), member_3_size))
    return std::unexpected(parse_error::buffer_exhausted);
  return instance;
}
```
---
class: middle
- Length prefixed vectors
--

count: false
- Unions / TLV
--

count: false
- Endianness
--

count: false
- Validation of Field Values
--

count: false
- Delimited Fields
--

count: false
- Magic Numbers
---
### Or as Dr.Stephan Strange said,
```c 
struct hands {
  char left_hand[4];
  char right_hand[4];
};
hands h{};
strcpy(h.left_hand, "things.....");
printf("%s %s\n", h.left_hand, h.right_hand);
```
---
.center[![dr_strange](./images/dr_strange.gif)]
---
### Possible Solutions
- Custom DSL 
- Rolling out a custom DSL and code generator
- Template Metaprogramming Magic
- &#x1F381
---
.center[![i_like_this](./images/i_like_this.png)]
---
class: center, middle
### &#x26A0 Template Metaprogramming Ahead!
---
class: center, middle
# TMP Primer
---
### Variadic Templates
```cpp
template <typename... Args>
struct type_list {};
```
- ... before template variable in the template declaration denotes definition
- ... after template variable in the body of the template denotes expansion
---
### Metafunctions
A function executed in compile time 
- which takes types or values known at compile time as input
- returns types or values known at compile time
- typically implemented with class templates, specializations and using aliases
```
f(T) => T | V
f(V) => T | V
```
--
count: false
Typical example, from the STL
```cpp
template< class T >
using remove_cv_t = typename remove_cv<T>::type;
```
--
count: false
Metafunctions are composable
```cpp
template<class T>
struct remove_cvref {
  using type = std::remove_cv_t<std::remove_reference_t<T>>;
};
```
---
count: false
It is possible to roll out one's own metafunction
```cpp
template <typename T>
struct is_optional_like;

template <typename T>
struct is_optional_like {
  static inline constexpr bool res = false;
};

template <typename T>
struct is_optional_like<std::optional<T>> {
  static inline constexpr bool res = true;
};

template <typename T>
inline constexpr bool is_optional_like_v = is_optional_like<T>::res;

template <typename T>
concept optional_like = is_optional_like_v<T>;
```
???
- One can roll out a function to search a type_list with a predicate
- Sort it
---
class: center, middle
# Lets write our parser
---
### Our Dream [Spoiler - would stay as dream &#x1F605]
```
struct_field_list(
  basic_field("a", u32, field_size(fixed(4))),
  basic_field("b", u32, field_size(fixed(4)))
);

struct_field_list(
  basic_field("len", std::size_t, field_size(fixed(8))),
  str_field("str", field_size(len_from_field("len")))
);

struct_field_list(
  basic_field("a", u32, field_size(fixed(4))),
  basic_field("b", u32, field_size(fixed(4))),
  variance(
    "c",
    type(
      match_field("a"),
      type_switch(
        match_case(0xcafed00d, as_struct(inner_1)),
        match_case(0xdeadbeef, as_struct(inner_2))
      )
    )
  )
);
```
---
### Reality
```cpp
* s2s::struct_field_list<
*  s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>,
*  s2s::basic_field<"b", u32, s2s::field_size<s2s::fixed<4>>>
* >;

* s2s::struct_field_list<
*  s2s::basic_field<"len", std::size_t, s2s::field_size<s2s::fixed<8>>>,
*  s2s::str_field<"str", s2s::field_size<s2s::len_from_field<"len">>>
* >;

s2s::struct_field_list<
  s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>,
  s2s::basic_field<"b", u32, s2s::field_size<s2s::fixed<4>>>,
  s2s::variance<
    "c",
    s2s::type<
      s2s::match_field<"a">,
      s2s::type_switch<
        s2s::match_case<0xcafed00d, s2s::as_struct<inner_1>>,
        s2s::match_case<0xdeadbeef, s2s::as_struct<inner_2>>
      >
    >
  >
>;
```
---
class: center, middle

```cpp
s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>
```
???
- A fixed compile time string as field named
- The type of the field
- A size hint
---
### Construct for string template arguments
```cpp
template <std::size_t N>
struct fixed_string {
  std::array<char, N + 1> value;
  constexpr fixed_string(): value{} {};
  constexpr fixed_string(const char (&str)[N + 1]) {
    std::copy_n(str, N + 1, value.data());
  }
  constexpr const char* data() const { return value.data(); }
  constexpr char* data() { return value.data(); }
  constexpr std::size_t size() const { return N; }
  constexpr auto to_sv() -> std::string_view const {
    return std::string_view{data()};
  }
};

template <std::size_t N>
fixed_string(const char (&)[N]) -> fixed_string<N - 1>;

template <std::size_t N1, std::size_t N2>
constexpr bool operator==(fixed_string<N1> lhs, fixed_string<N2> rhs) {
  if constexpr(N1 != N2) return false;
  return std::string_view{lhs.data()} == std::string_view{rhs.data()};
}
```
---
### Literals for accessing our fields
```cpp
template <fixed_string id>
struct field_accessor {
  static constexpr auto field_id = id;
};


namespace s2s_literals {
template <fixed_string id>
constexpr auto operator""_f() {
  return field_accessor<id>{};
}
}
```
--
count: false
Now we can do this,
```cpp
fields["hello"_f];
```
---
### Denoting sizes
```cpp
template <typename size_type>
struct field_size {
  using size_type_t = size_type;
};

template <std::size_t N>
struct fixed {
  static constexpr auto count = N;
};

template <fixed_string id>
using len_from_field = field_accessor<id>;

template <auto callable, typename req_fields>
struct size_from_fields {
  static constexpr auto f = callable;
  static constexpr auto req_field_list = req_fields{};
};
```
---
We can denote
--
count: false
- Name &#x2705
--
count: false
- Size &#x2705
--
count: false
- Type &#x2705
--
count: false

```cpp
template <
  fixed_string id, 
  typename T, 
  typename size_type, 
  auto constraint_on_value
>
struct field {
  using field_type = T;
  using field_size = size_type;

  static constexpr auto field_id = id;
  static constexpr auto constraint_checker = constraint_on_value;
  field_type value{};
};
```
--
count: false
```cpp
s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>> &#x2705
```
---
### Struct
```cpp
template <typename... fields>
  requires are_unique_fields_v<fields...>
struct struct_field_list : fields... {
  template <typename field_accessor,
            typename field = field_lookup_v<
              type_list<fields...>, 
              field_accessor::field_id>
            >
    requires (!std::is_same_v<field_lookup_failed, field>)
  constexpr auto& operator[](field_accessor)  {
    return static_cast<field&>(*this).value;
  }

  template <typename field_accessor,
            typename field = field_lookup_v<
              type_list<fields...>, 
              field_accessor::field_id>
    requires (!std::is_same_v<field_lookup_failed, field>)
  constexpr const auto& operator[](field_accessor) const {
    return static_cast<const field&>(*this).value;
  }
};
```
---
### How the accessor[] works here?
Static casting the "struct" which is inherited from multiple fields to one valid field, leads to object slicing and only the base field from which struct was inherited is returned by reference
.center[![valid_cast](./images/cast_valid_object_slicing.png)]
---
count: false
.center[![invalid_cast](./images/cast_invalid_object_slicing.png)]

```sh
<source>:33:24: error: no viable overloaded operator[] for type 's2s::struct_field_list_impl<2UL, s2s::field<fixed_string<2UL - 1>{{"a"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>, s2s::field<fixed_string<2UL - 1>{{"b"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>> const'
   33 |     std::cout << fields["e"_f] << fields["b"_f];
      |                  ~~~~~~^~~~~~
/app/raw.githubusercontent.com/hariceratops/s2s/main/single_header/s2s.hpp:2181:19: note: candidate function template not viable: 'this' argument has type 's2s::struct_field_list_impl<2UL, s2s::field<fixed_string<2UL - 1>{{"a"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>, s2s::field<fixed_string<2UL - 1>{{"b"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>> const', but method is not marked const
 2181 |   constexpr auto& operator[](field_accessor)  {
      |                   ^
/app/raw.githubusercontent.com/hariceratops/s2s/main/single_header/s2s.hpp:2191:25: note: candidate template ignored: constraints not satisfied [with field_accessor = s2s::field_accessor<s2s::fixed_string<2UL - 1>{{"e"}}>, field_lookup_res = static_optional<field_type_info>{{0, 0}, false}]
 2191 |   constexpr const auto& operator[](field_accessor) const {
      |                         ^
/app/raw.githubusercontent.com/hariceratops/s2s/main/single_header/s2s.hpp:2190:15: note: because 'static_optional<field_type_info>{{0, 0}, false}.has_value' evaluated to false
 2190 |     requires (!std::is_same_v<field_lookup_failed, field>)
      |
```
???
- Not the prettiest error message, this is as good as it gets
- In fact clang does a great job with being succtinct
---
### How does the lookup work?
```cpp
struct field_lookup_failed {};

template <typename ls, fixed_string id>
struct field_lookup;

template <fixed_string id>
struct field_lookup<type_list<>, id> {
  using type = field_lookup_failed;
};
template <fixed_string id, typename T, std::size_t size, typename... rest>
struct field_lookup<type_list<field<id, T, size>, rest...>, id> {
  using type = field<id, T, size>;
};

template <fixed_string id, typename head, typename... rest>
struct field_lookup<type_list<head, rest...>, id> {
  using type = typename field_lookup<field_list<rest...>, id>::type;
};

template <typename list, fixed_string id>
using field_lookup_v = typename field_lookup<list, id>::type;
```
???
- If we have exhausted the list, we have not found the field we are trying access in the struct- Since the names are ensured to be unique, it is guaranteed we will have just one hit for our field
---
```cpp
enum error_reason {
  buffer_exhaustion,
  validation_failure,
  type_deduction_failure
};


struct cast_error {
  error_reason failure_reason;
  std::string_view failed_at;
};


using rw_result = std::expected<void, error_reason>;
using cast_result = std::expected<void, cast_error>;
```
---

Link to project: [s2s](https://github.com/hariceratops/s2s)
```cpp
return 0;
```
???
- Dont be afraid to do a project, even at the cost of failing
- It takes a village


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
    var slideshow = remark.create({
        highlightLines: true
    });
    </script>
  </body>
</html>
