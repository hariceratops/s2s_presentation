<!-- https://github.com/gnab/remark/issues/538#issuecomment-419173985 -->
<!-- todo: offline version -->
<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Rubik);
      @import url(https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700,400italic);

      body { font-family: 'Rubik'; }
      h1 {
        font-family: 'Rubik';
        font-weight: bold;
      }
      h2, h3 {
        font-family: 'Rubik';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Source Code Pro'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Binary Parsing, C++23 Style
### Hari Prasad Manoharan

---
### About Me

```bash
> whoami
USER:hari
COMPANY:mbition
GIT:https://github.com/hariceratops/
LINKEDIN:https://www.linkedin.com/in/hari-prasad-manoharan-79a4ba102/
MASTODON:@hariceratops@mastodon.social
PRIMARY_DOMAIN:embedded_systems
ENGINEER_SINCE:2016_08_16
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- Working as a SWE in Mbition, a subsidiary of Mercedes
  developing Infotainment SW
- At my team, we are creating APIs for application developers
  to exchange data with other control units and try to abstract
  the underlying communication protocols and promote API
  reusability among car lines
---
### Disclaimer

- I am not an expert, I am just a dude
- The views presented are not of my employer
- Project is not production ready, at least not yet!
- We will walkthrough the simplified version of the project source

<!-- -------------------- Speaker Notes ------------------- -->
???
- I have been developing SW with C++ for past 6 years or so
  So take my advice with a pinch of salt 
- We walkthrough a simplified version of the project because
  - The original project is close to 5000 lines and would be not practical 
  to go through it in a talk
  - Most metaprogramming talks still appear like magic, so the idea is to 
    skim through the basic version
    to cover as much details as possible
  - This way we avoid the famous meme, first you draw circle and next 
    step you end up with an owl
---
### How this came to be?
- Parsing binary format is something any developer would run into at some point
- No declarative way to describe a binary format in C++
- What is more fun than writing something from scratch?
- Came across following projects which led to some solid work
  - [CTRE, Hana Dusíková](https://www.youtube.com/watch?v=g51_HYn_CqE&t=1232s)
  - [namedtuple++, Kris Jusiak](https://www.youtube.com/watch?v=4PwNi0Zgmm0)
  - [Value Based Metaprogramming, Kris Jusiak](https://www.youtube.com/watch?v=yriNqhv-oM0)

<!-- -------------------- Speaker Notes ------------------- -->
???
- Too much boiler plate if handwritten, code generation was not appealing
- Thanks to Kris, Hana
- As a side note, watch talks, attend conferences and meet people
---
class: center, middle
# Fact Check!

<!-- -------------------- Speaker Notes ------------------- -->
???
- I wanted to do a quiz since I was planning a onsite talk
  but I will have to turn it into fact check
---
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};
auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance), sizeof(instance));
  std::println("{:X} {:X} {:X}", 
    instance.member_1, 
    instance.member_2, 
    instance.member_3
  );
};
```
```sh
# Input: file.bin
0x000000: 0xef 0xbe 0xad 0xde ....
0x000004: 0x0d 0xd0 0xfe 0xca ....
0x000008: 0xef 0xbe 0xef 0xbe ....
0x00000c:
   bytes: 12
```
--
count: false
```sh
deadbeef cafed00d beefbeef
```
---
```cpp
struct some_thing {
  uint32_t member_1;
* uint8_t member_2;
  uint32_t member_3;
};
auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance), sizeof(instance));
  std::println("{:X} {:X} {:X}", 
    instance.member_1, 
    instance.member_2,
    instance.member_3
  );
};
```
```sh
# Input: file.bin
0x000000: 0xef 0xbe 0xad 0xde ....
*0x000004: 0x2a 0x0d 0xd0 0xfe ....
0x000008: 0xca                ....
0x00000c:
   bytes: 9
```
--
count: false
```sh
deadbeef 2a ca7f
```
---
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};

auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance), sizeof(instance));
  std::println("{:X} {:X} {:X}", 
    instance.member_1, 
    instance.member_2, 
    instance.member_3
  );
};
```
```sh
  0x000000: 0xef 0xbe 0xad 0xde ....
* 0x000004: 0x42 0x42 0x42 0x0d ....
  0x000008: 0xd0 0xfe 0xca      ....
  0x00000c:
   bytes: 11
```
--
count: false
```sh
deadbeef d424242 c9cafed0
```
---
Solution
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};

auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;          
  file.read(reinterpret_cast<char*>(&instance.member_1), sizeof(instance.member_1));
  file.read(reinterpret_cast<char*>(&instance.member_2), 3);
  file.read(reinterpret_cast<char*>(&instance.member_3), sizeof(instance.member_3));
  std::println("{:X} {:X} {:X}", instance.member_1, instance.member_2, instance.member_3);
  file.close();
};
```
---
count: false
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};

auto parse_something(std::ifstream& file) -> some_thing {
  constexpr std::size_t member_1_size = sizeof(instance.member_1);
  constexpr std::size_t member_2_size = 3;
  constexpr std::size_t member_3_size = sizeof(instance.member_3);

  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance.member_1), member_1_size);
  file.read(reinterpret_cast<char*>(&instance.member_2), member_2_size);
  file.read(reinterpret_cast<char*>(&instance.member_3), member_3_size);
  return instance;
}

auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance = parse_something();          
  std::println("{:X} {:X} {:X}",
    instance.member_1, 
    instance.member_2, 
    instance.member_3
  );
  file.close();
};
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- Lets clean it up for readability
---
Lets throw this to our code
```sh
0x000000: 0xef 0xbe 0xad 0xde ....
0x000004: 0x42 0x42 0x42 0x0d ....
0x000008:                     ....
0x00000c:
   bytes: 8
```
--
count: false
We will have to handle buffer exhaustion now
--
count: false
```cpp
enum parse_error { buffer_exhausted = 0 };
using parse_res = std::expected<some_thing, parse_error>;

auto parse_something(std::ifstream& file) -> parse_res {
  constexpr std::size_t member_1_size = sizeof(instance.member_1);
  constexpr std::size_t member_2_size = 3;
  constexpr std::size_t member_3_size = sizeof(instance.member_3);

  some_thing instance;
  if(!file.read(reinterpret_cast<char*>(&instance.member_1), member_1_size))
    return std::unexpected(parse_error::buffer_exhausted);
  if(!file.read(reinterpret_cast<char*>(&instance.member_2), member_2_size))
    return std::unexpected(parse_error::buffer_exhausted);
  if(!file.read(reinterpret_cast<char*>(&instance.member_3), member_3_size))
    return std::unexpected(parse_error::buffer_exhausted);
  return instance;
}
```
---
```cpp
struct some_thing {
  uint32_t member_1;
  bool member_2;
  // Has to be parsed only if member_2 == true
  std::optional<uint32_t> member_3;
};
```
--
count: false
```cpp
auto parse_something(std::ifstream& file) -> parse_res {
  constexpr std::size_t member_1_size = sizeof(instance.member_1);
  constexpr std::size_t member_2_size = 3;
  constexpr std::size_t member_3_size = sizeof(instance.member_3);

  some_thing instance;
  if(!file.read(reinterpret_cast<char*>(&instance.member_1), member_1_size))
    return std::unexpected(parse_error::buffer_exhausted);
* if(instance.member_2 && !file.read(reinterpret_cast<char*>(&instance.member_2), member_2_size))
    return std::unexpected(parse_error::buffer_exhausted);
  if(!file.read(reinterpret_cast<char*>(&instance.member_3), member_3_size))
    return std::unexpected(parse_error::buffer_exhausted);
  return instance;
}
```
---
class: middle

- Nested structs
--

count: false
- Length prefixed vectors
--

count: false
- Unions / TLV
--

count: false
- Endianness
--

count: false
- Validation of Field Values
--

count: false
- Delimited Fields
--

count: false
- Magic Numbers
---
### Or as Dr.Stephan Strange said,
```c 
struct hands {
  char left_hand[4];
  char right_hand[4];
};
hands h{};
strcpy(h.left_hand, "things.....");
printf("%s %s\n", h.left_hand, h.right_hand);
```
---
.center[![dr_strange](./images/dr_strange.gif)]
---
### Possible Solutions
- Existing DSL like [Kaitai](https://doc.kaitai.io/user_guide.html)
- Rolling out a custom DSL and code generator
- Template Metaprogramming Magic
- &#x1F381
---
.center[![i_like_this](./images/i_like_this.png)]


<!-- -------------------- Speaker Notes ------------------- -->
???
- But I chose TMP
- Why?
  - I wanted to explore the depths the language
  - More importantly it is related to the little suprise I talked about in the
    previous slide
---
### The promise
- No macros
--
count: false
- Reasonably good error messages
--
count: false
- constexpr! as much as possible
--
count: false
- Support for
  - Trivial
  - Array of trivials
  - Array of records
  - Length prefixed vector of trivials
  - Length prefixed vector of records
  - Const sized strings
  - Length prefixed strings
  - Optionals
  - Unions
  - Magic strings and numbers
--
count: false
- Validation of fields in place while reading
--
count: false
- Compile time endianness handling
--
count: false
- Works with any custom streams
---
### The promise
```cpp
  #include "s2s.hpp"
  #include <print>

  using namespace s2s_literals;

  auto main(void) -> int {
*   using our_struct = 
*     s2s::struct_field_list<
*       s2s::basic_field<"len", std::size_t, s2s::field_size<s2s::fixed<8>>>,
*       s2s::str_field<"str", s2s::field_size<s2s::len_from_field<"len">>>
*     >;
    std::ifstream ifs("sample.bin", std::ios::in | std::ios::binary);
    auto res = 
*     s2s::struct_cast<our_struct>(ifs)
          .transform([](const our_struct& fields){
            std::println("len={} str={}", fields["len"_f], fields["str"_f]);
            return fields;
          }).transform_error([](const s2s::cast_error& err){
            std::println("failure_reason={} failed_at={}", static_cast<int>(err.failure_reason), err.failed_at);
            return err;
          });
    return 0;
  }
```
---
class: center, middle
# Lets write our parser
---
class: center, middle
### &#x26A0 Template Metaprogramming Ahead!

<!-- -------------------- Speaker Notes ------------------- -->
???
- I have had love-hate relationship with TMP
- Whenever I write template typename ..., I get faces, I mean not angry faces, 
  but not happy faces
- I do get the sentiment here, they are hard to get right, slower compile times
- But TMP has its place, like our little project
---
### TMP Primer Materials
- Variadic Templates
  - [... + CTAD + NTTP](https://www.youtube.com/watch?v=Hyuvpv42YM8) by Miro Knejp
- Metafunctions 
  - [Compile Time Functional Programming](https://www.youtube.com/watch?v=WtHWFoKf8o0) by Bartosz Milewski, Eric Niebler 


<!-- -------------------- Speaker Notes ------------------- -->
???
- It is not mandatory to know these concepts before hand for the talk
- But in case if the topics are unfamiliar here are some great talks online to 
  get a grasp of them
- todo definition of variadic templates and functions
- Parameter packs can be expanded into binary operation using left or right 
  fold expression according to required associativity
- Lets you define list which can hold types
- A function executed in compile time 
  - which takes types or values known at compile time as input
  - returns types or values known at compile time
  - typically implemented with class templates, specializations and using aliases
- Similar to a function which searches for an element in a list of cast_valid_objects 
  One can roll out a function to search a type_list with a predicate
---
### What are we building?
```cpp
s2s::struct_field_list<
  s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>,
  s2s::basic_field<"b", u32, s2s::field_size<s2s::fixed<4>>>
>;

s2s::struct_field_list<
  s2s::basic_field<"len", std::size_t, s2s::field_size<s2s::fixed<8>>>,
  s2s::str_field<"str", s2s::field_size<s2s::len_from_field<"len">>>
>;
```
---
class: center, middle

```cpp
s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- A fixed compile time string as field named
- The type of the field
- A size hint
---
### Construct for string template arguments
```cpp
template <std::size_t N>
struct fixed_string {
```
---
count: false
### Construct for string template arguments
```cpp
template <std::size_t N>
struct fixed_string {
  std::array<char, N + 1> value;
  constexpr fixed_string(): value{} {};
  constexpr fixed_string(const char (&str)[N + 1]) {
    std::copy_n(str, N + 1, value.data());
  }
```
---
count: false
### Construct for string template arguments
```cpp
template <std::size_t N>
struct fixed_string {
  std::array<char, N + 1> value;
  constexpr fixed_string(): value{} {};
  constexpr fixed_string(const char (&str)[N + 1]) {
    std::copy_n(str, N + 1, value.data());
  }
  constexpr const char* data() const { return value.data(); }
  constexpr char* data() { return value.data(); }
  constexpr std::size_t size() const { return N; }
  constexpr auto to_sv() -> std::string_view const {
    return std::string_view{data()};
  }
};
```
---
count: false
### Construct for string template arguments
```cpp
template <std::size_t N>
struct fixed_string {
  std::array<char, N + 1> value;
  constexpr fixed_string(): value{} {};
  constexpr fixed_string(const char (&str)[N + 1]) {
    std::copy_n(str, N + 1, value.data());
  }
  constexpr const char* data() const { return value.data(); }
  constexpr char* data() { return value.data(); }
  constexpr std::size_t size() const { return N; }
  constexpr auto to_sv() -> std::string_view const {
    return std::string_view{data()};
  }
};

template <std::size_t N>
fixed_string(const char (&)[N]) -> fixed_string<N - 1>;

template <std::size_t N1, std::size_t N2>
constexpr bool operator==(fixed_string<N1> lhs, fixed_string<N2> rhs) {
  if constexpr(N1 != N2) return false;
  return std::string_view{lhs.data()} == std::string_view{rhs.data()};
}
```
---
count: false
### Construct for string template arguments
Now this should be possible

```cpp
template <fixed_string id>
struct sample {};

sample<"hello"> s{};
```
---
### Literals for accessing our fields
```cpp
template <fixed_string id>
struct field_accessor {
  static constexpr auto field_id = id;
};


namespace s2s_literals {
template <fixed_string id>
constexpr auto operator""_f() {
  return field_accessor<id>{};
}
}
```
--
count: false
Now we can do this,
```cpp
// if a hypotheical type supports a square bracket 
// operator with field_accessor as input argument 
fields["hello"_f];
```
---
### Denoting sizes
```cpp
// Private, useful for struct fields
struct size_dont_care {};

template <typename size_type>
struct field_size {
  using size_type_t = size_type;
};

template <std::size_t N>
struct fixed {
  static constexpr auto count = N;
};

template <fixed_string id>
using len_from_field = field_accessor<id>;
```
---
We can denote
--
count: false
- Name &#x2705
--
count: false
- Size &#x2705
--
count: false
- Type &#x2705
--
count: false

```cpp
template <
  fixed_string id, 
  typename T, 
  typename size_type
>
struct field {
  using field_type = T;
  using field_size = size_type;

  static constexpr auto field_id = id;
  field_type value{};
};
```
--
count: false
```cpp
s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>> &#x2705
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- The best thing here is that we can put another struct_field_list
  inside our field, which makes nested structs possible
---
class: middle
```cpp
s2s::struct_field_list<
  s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>,
  s2s::basic_field<"b", u32, s2s::field_size<s2s::fixed<4>>>
>;
```
---
### Struct
```cpp
template <typename... fields>
  requires are_unique_fields_v<fields...> && size_dependencies_resolved_v<fields...>
struct struct_field_list : fields... {
```
---
count: false
### Struct
```cpp
template <typename... fields>
  requires are_unique_fields_v<fields...> && size_dependencies_resolved_v<fields...>
struct struct_field_list : fields... {
  template <typename field_accessor,
            typename field = field_lookup_v<
              type_list<fields...>, 
              field_accessor::field_id>
            >
    requires (!std::is_same_v<field_lookup_failed, field>)
  constexpr auto& operator[](field_accessor)  {
```
---
count: false
### Struct
```cpp
template <typename... fields>
  requires are_unique_fields_v<fields...> && size_dependencies_resolved_v<fields...>
struct struct_field_list : fields... {
  template <typename field_accessor,
            typename field = field_lookup_v<
              type_list<fields...>, 
              field_accessor::field_id>
            >
    requires (!std::is_same_v<field_lookup_failed, field>)
  constexpr auto& operator[](field_accessor)  {
    return static_cast<field&>(*this).value;
  }
```
---
count: false
### Struct
```cpp
template <typename... fields>
  requires are_unique_fields_v<fields...> && size_dependencies_resolved_v<fields...>
struct struct_field_list : fields... {
  template <typename field_accessor,
            typename field = field_lookup_v<
              type_list<fields...>, 
              field_accessor::field_id>
            >
    requires (!std::is_same_v<field_lookup_failed, field>)
  constexpr auto& operator[](field_accessor)  {
    return static_cast<field&>(*this).value;
  }

  template <typename field_accessor,
            typename field = field_lookup_v<
              type_list<fields...>, 
              field_accessor::field_id>
            >
    requires (!std::is_same_v<field_lookup_failed, field>)
  constexpr const auto& operator[](field_accessor) const {
    return static_cast<const field&>(*this).value;
  }
};
```
---
### How uniqueness and dependencies are guaranteed
##&#x1F44B
- They are metafunctions to 
  - check if there are no repetition in field names 
  - if a field depends on another field for its size, then the dependency occurs strictly to left
- Not adhering to this constraints will result in compile time errors


<!-- -------------------- Speaker Notes ------------------- -->
???
- Requires are_unique_fields_v<fields...> && size_dependencies_resolved_v<fields...>
- Will skip the complete walkthrough for are_unique_fields_v and size_dependencies_resolved_v
---
### How does the lookup work?
```cpp
template <typename ... types>
struct type_list {};

struct field_lookup_failed {};

template <typename ls, fixed_string id>
struct field_lookup;

template <fixed_string id>
struct field_lookup<type_list<>, id> {
  using type = field_lookup_failed;
};
template <fixed_string id, typename T, typename size, typename... rest>
struct field_lookup<type_list<field<id, T, size>, rest...>, id> {
  using type = field<id, T, size>;
};

template <fixed_string id, typename head, typename... rest>
struct field_lookup<type_list<head, rest...>, id> {
  using type = typename field_lookup<type_list<rest...>, id>::type;
};

template <typename list, fixed_string id>
using field_lookup_v = typename field_lookup<list, id>::type;
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- If we have exhausted the list, we have not found the field we are 
trying access in the struct
- Since the names are ensured to be unique, it is guaranteed we will have just one hit for our field
---
### How the accessor[] works here?
Static casting the "struct" which is inherited from multiple fields to one valid field, 
leads to object slicing and only the base field from which struct was inherited is returned by reference
.center[![valid_cast](./images/cast_valid_object_slicing.png)]
---
count: false
.center[![invalid_cast](./images/cast_invalid_object_slicing.png)]

```sh
<source>:33:24: error: no viable overloaded operator[] for type 's2s::struct_field_list_impl<2UL, s2s::field<fixed_string<2UL - 1>{{"a"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>, s2s::field<fixed_string<2UL - 1>{{"b"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>> const'
   33 |     std::cout << fields["e"_f] << fields["b"_f];
      |                  ~~~~~~^~~~~~
/app/raw.githubusercontent.com/hariceratops/s2s/main/single_header/s2s.hpp:2181:19: note: candidate function template not viable: 'this' argument has type 's2s::struct_field_list_impl<2UL, s2s::field<fixed_string<2UL - 1>{{"a"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>, s2s::field<fixed_string<2UL - 1>{{"b"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>> const', but method is not marked const
 2181 |   constexpr auto& operator[](field_accessor)  {
      |                   ^
/app/raw.githubusercontent.com/hariceratops/s2s/main/single_header/s2s.hpp:2191:25: note: candidate template ignored: constraints not satisfied [with field_accessor = s2s::field_accessor<s2s::fixed_string<2UL - 1>{{"e"}}>, field_lookup_res = static_optional<field_type_info>{{0, 0}, false}]
 2191 |   constexpr const auto& operator[](field_accessor) const {
      |                         ^
/app/raw.githubusercontent.com/hariceratops/s2s/main/single_header/s2s.hpp:2190:15: note: because 'static_optional<field_type_info>{{0, 0}, false}.has_value' evaluated to false
 2190 |     requires (!std::is_same_v<field_lookup_failed, field>)
      |
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- Not the prettiest error message, this is as good as it gets
- In fact clang does a great job with being succtinct
---
class: middle
```cpp
s2s::struct_field_list<
  s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>,
  s2s::basic_field<"b", u32, s2s::field_size<s2s::fixed<4>>>
>;
```
&#x2705
---
### Errors
```cpp
enum error_reason {
  buffer_exhaustion
  /* maybe few more in the future */
};


struct cast_error {
  error_reason failure_reason;
  std::string_view failed_at;
};


using read_result = std::expected<void, cast_error>;
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- Note that read_result is for individual fields,
  not for the complete struct we wrote

---
### Utilities to calculate address and size of fields
```cpp
template <typename T>
char* byte_addressof(T& obj) {
  return reinterpret_cast<char*>(&obj);
}

char* byte_addressof(std::string& obj) {
  return reinterpret_cast<char*>(&obj[0]);
}

// other overloads
// std::array<T, N> -> return reinterpret_cast<char*>(&obj.data());
//
```

---
count: false

```cpp
template <typename T>
struct deduce_field_size;

template <fixed_string id, typename T, std::size_t N>
struct deduce_field_size<field<id, T, field_size<fixed<N>>>> {
  template <typename... fields>
  constexpr auto operator()(const struct_field_list<fields...>& struct_fields) -> std::size_t {
    return N;
  }
};

template <fixed_string id, typename T>
struct deduce_field_size<field<id, std::vector<T>, field_size<field_accessor<id>>>> {
  template <typename... fields>
  constexpr auto operator()(const struct_field_list<fields...>& struct_fields) -> std::size_t {
    return sizeof(T) * struct_fields[field_accessor<id>{}];
  }
};

template <fixed_string id, fixed_string size_src_id>
struct deduce_field_size<field<id, std::string, field_size<field_accessor<size_src_id>>>> {
  template <typename... fields>
  constexpr auto operator()(const struct_field_list<fields...>& struct_fields) -> std::size_t {
    return struct_fields[field_accessor<size_src_id>{}];
  }
};
```

---
### Monadic Pipeline
```cpp
constexpr auto operator|(const read_result& res, auto&& callable)
  -> read_result
{
  return res ? callable() : std::unexpected(res.error());
}
```
---

### We read atlast
```cpp
template <typename... args>
struct struct_cast_impl;

template <typename... fields, typename stream, auto endianness>
struct struct_cast_impl<struct_field_list<fields...>, stream, endianness> {
```

---
count: false

### We read atlast
```cpp
template <typename... args>
struct struct_cast_impl;

template <typename... fields, typename stream, auto endianness>
struct struct_cast_impl<struct_field_list<fields...>, stream, endianness> {
  using S = struct_field_list<fields...>;
  using R = std::expected<S, cast_error>;
```

---
count: false

### We read atlast
```cpp
template <typename... args>
struct struct_cast_impl;

template <typename... fields, typename stream, auto endianness>
struct struct_cast_impl<struct_field_list<fields...>, stream, endianness> {
  using S = struct_field_list<fields...>;
  using R = std::expected<S, cast_error>;

  constexpr auto operator()(stream& s) -> R {
```

---
count: false

### We read atlast
```cpp
template <typename... args>
struct struct_cast_impl;

template <typename... fields, typename stream, auto endianness>
struct struct_cast_impl<struct_field_list<fields...>, stream, endianness> {
  using S = struct_field_list<fields...>;
  using R = std::expected<S, cast_error>;

  constexpr auto operator()(stream& s) -> R {
    S field_list;
    read_result pipeline_seed{};
```

---
count: false

### We read atlast
```cpp
template <typename... args>
struct struct_cast_impl;

template <typename... fields, typename stream, auto endianness>
struct struct_cast_impl<struct_field_list<fields...>, stream, endianness> {
  using S = struct_field_list<fields...>;
  using R = std::expected<S, cast_error>;

  constexpr auto operator()(stream& s) -> R {
    S field_list;
    read_result pipeline_seed{};
    auto res = (
      pipeline_seed |
      ... |
      [&field_list]() -> read_result {
        auto& field = static_cast<fields&>(field_list);
        // Some read magic here &#x1FA84
      }
    );
```

---
### We read atlast
```cpp
template <typename... args>
struct struct_cast_impl;

template <typename... fields, typename stream, auto endianness>
struct struct_cast_impl<struct_field_list<fields...>, stream, endianness> {
  using S = struct_field_list<fields...>;
  using R = std::expected<S, cast_error>;

  constexpr auto operator()(stream& s) -> R {
    S field_list;
    read_result pipeline_seed{};
    auto res = (
      pipeline_seed |
      ... |
      [&field_list]() -> read_result {
        auto& field = static_cast<fields&>(field_list);
        // Some read magic here &#x1FA84
      }
    );
    return res ? R(field_list) : std::unexpected(res.error());
  }
};
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- Short circuit the remaining pipeline since read failed for current field
- Box unwrapping diagram?
---
### &#x1FA84

```cpp
using underlying_type = extract_type_from_field_v<fields>;

if constexpr (field_list_like<underlying_type>) {
```
---
count: false

### &#x1FA84

```cpp
using underlying_type = extract_type_from_field_v<fields>;

if constexpr (field_list_like<underlying_type>) {
  auto field_value = struct_cast<underlying_type>(s);
  if(!field_value) 
    return std::unexpected(field_value.error());
```
---
count: false

### &#x1FA84

```cpp
using underlying_type = extract_type_from_field_v<fields>;

if constexpr (field_list_like<underlying_type>) {
  auto field_value = struct_cast<underlying_type>(s);
  if(!field_value) 
    return std::unexpected(field_value.error());
} else if constexpr (
    constant_sized_like<underlying_type> || 
    variable_sized_buffer_like<underlying_type>
  )
```
---
count: false

### &#x1FA84

```cpp
using underlying_type = extract_type_from_field_v<fields>;

if constexpr (field_list_like<underlying_type>) {
  auto field_value = struct_cast<underlying_type>(s);
  if(!field_value) 
    return std::unexpected(field_value.error());
} else if constexpr (
    constant_sized_like<underlying_type> || 
    variable_sized_buffer_like<underlying_type>
  )
{
  auto read_size = deduce_field_size<fields>{}(field_list);
  if constexpr(variable_sized_buffer_like<underlying_type>)
    field.value.resize(read_size);
```
---
count: false

### &#x1FA84

```cpp
using underlying_type = extract_type_from_field_v<fields>;

if constexpr (field_list_like<underlying_type>) {
  auto field_value = struct_cast<underlying_type>(s);
  if(!field_value) 
    return std::unexpected(field_value.error());
} else if constexpr (
    constant_sized_like<underlying_type> || 
    variable_sized_buffer_like<underlying_type>
  )
{
  auto read_size = deduce_field_size<fields>{}(field_list);
  if constexpr(variable_sized_buffer_like<underlying_type>)
    field.value.resize(read_size);
  if(!s.read(byte_addressof(field.value), read_size)) {
    constexpr auto field_name = fields::field_id.to_sv();
    return std::unexpected(cast_error{buffer_exhaustion, field_name});
  }
}
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- "if constexpr" clauses which only satisfy the condition at compile time are
  considered in the binary
- If we have a nested struct, we might have to extract the struct type
  from the field, since we need to pass the type of the struct as a 
  template parameter to the recursive struct_cast function
---
### User API - Cast
```cpp
template <field_list_like T, input_stream_like stream>
[[nodiscard]] constexpr auto struct_cast(stream& s)
  -> std::expected<T, cast_error> 
{
  return struct_cast_impl<T, stream>{}(s);
}
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- These are user facing APIs with constraints to avoid misuse and provide relatively
  clean error messages
---
### User API - Field Descriptors
```cpp
template <typename size, typename field_type>
concept field_fits_to_underlying_type =
  size::size_type_t::count <= sizeof(field_type);

template <fixed_string id, integral T, fixed_size_like size_type>
  requires field_fits_to_underlying_type<size_type, T>
using basic_field = field<id, T, size_type>;

template <fixed_string id, field_containable T, std::size_t N>
using fixed_array_field = 
  field<id, std::array<T, N>, field_size<fixed<N * sizeof(T)>>>;

template <fixed_string id, std::size_t N>
using fixed_string_field = 
  field<id, fixed_string<N>, field_size<fixed<N + 1>>>;

template <fixed_string id, typename T, variable_size_like size>
using vec_field = field<id, std::vector<T>, size>;

template <fixed_string id, variable_size_like size>
using str_field = field<id, std::string, size>;

template <fixed_string id, field_list_like T>
using struct_field = field<id, T, field_size<size_dont_care>>;

```

<!-- -------------------- Speaker Notes ------------------- -->
???
- Just like the cast function we add some user facing Meta-APIs
  for describing fields
- For example we have a basic field which ensures that users cant read bytes more
  than the actual size of the trivial type
- Similarly we can make the user's life easy by not having them to calculate
  number of bytes to read in case of array types, they can simply provide the number of
  elements and library would provide a MetaAPI to wrap the size calculation
- This also in many ways avoid human errors
---
Field descriptors &#x2705
--
count: false
, Data layout &#x2705
--
count: false
, Cast API &#x2705
--
count: false
, Cast implementation &#x2705
--
count: false

Et viola! [Link to Godbolt](https://godbolt.org/z/doW98c6oY)

```cpp
  #include "s2s.hpp"
  #include <print>

  using namespace s2s_literals;

  auto main(void) -> int {
*   using our_struct = 
*     s2s::struct_field_list<
*       s2s::basic_field<"len", std::size_t, s2s::field_size<s2s::fixed<8>>>,
*       s2s::str_field<"str", s2s::field_size<s2s::len_from_field<"len">>>
*     >;
    std::ifstream ifs("sample.bin", std::ios::in | std::ios::binary);
    auto res = 
*     s2s::struct_cast<our_struct>(ifs)
          .transform([](const our_struct& fields){
            std::println("len={} str={}", fields["len"_f], fields["str"_f]);
            return fields;
          }).transform_error([](const s2s::cast_error& err){
            std::println("failure_reason={} failed_at={}", static_cast<int>(err.failure_reason), err.failed_at);
            return err;
          });
    return 0;
  }
```
<!-- -------------------- Speaker Notes ------------------- -->
???
- We might have not have built everything here in the talk
  But it is in possible to implement these features with the
  principles we established
---
### Benchmarks
todo

<!-- -------------------- Speaker Notes ------------------- -->
???
- But we are not quite done yet, remember the little suprised
  we reserved for the end
---
### &#x1F381 = Reflection &#x2661
- C++26 or future standards promises
  - [Static Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2996r0.html)
  - [Annotation for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3394r0.html)
--
count:false
- Lets you write readable annotation similar to Rust

``` rust
#[derive(BinRead)]
#[br(magic = b"DOG", assert(name.len() != 0))]
struct Dog {
    bone_pile_count: u8,
    #[br(big, count = bone_pile_count)]
    bone_piles: Vec<u16>,
}
```
``` cpp
struct [[=readable_from_stream]] Dog {
  [[=requires_value("DOG")]]
  fixed_string<3> magic;
  uint8_t bone_pile_count;
  [[=field_len("bone_pile_count"), =endian("be")]]
  bone_piles: Vec<u16>;
}
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- Obliged to bring Rust in the talk
- binrw is an equivalent to our little project here
- It uses Rust proc macros to annotate the structs with details needed
  for parsing it from a stream and later generate code for the parser
- But the difference is how the code is generated, proc macros
  can read the tokens from your code, lets you to introspect them 
  and inject tokens back into the AST
- c++26 and beyond will support static reflection
- Enables introspection and annotation but no code generation 
- No token injection like rust proc macros but
  we have our good old friend templates
- One reason I wanted to write this project in c++23 with TMP
  is, it can be easily ported to static reflection based implementation 
- In fact the latest code on github relies on value based metaprogramming
  which can be easily ported to the reflection proposal

---
### In a galaxy not so far away!
```cpp
  #include "s2s.hpp"
  #include <print>

* struct [[=readable_from_stream]] Dog {
*   std::size_t len;
*   [[=field_len("len")]]
*   std::string str;
* }

  auto main(void) -> int {
    std::ifstream ifs("sample.bin", std::ios::in | std::ios::binary);
    auto res = 
*     s2s::struct_cast<our_struct>(ifs)
          .transform([](const our_struct& fields){
*           std::println("len={} str={}", fields["len_f"], fields["len_f"]);
            return fields;
          }).transform_error([](const s2s::cast_error& err){
            std::println("failure_reason={} failed_at={}", static_cast<int>(err.failure_reason), err.failed_at);
            return err;
          });
    return 0;
  }
```

<!-- -------------------- Speaker Notes ------------------- -->
???
- Replace the user facing API with annotated structs and still let the new code
  use our template based parser generator underneath
- This might be a partially breaking change, especially for user facing API
  But it is for the greater good since it is readable

---
count: false
### In a galaxy not so far away!
```cpp
  #include "s2s.hpp"
  #include <print>

* struct [[=readable_from_stream]] Dog {
*   std::size_t len;
*   [[=field_len("len")]]
*   std::string str;
* }

  auto main(void) -> int {
    std::ifstream ifs("sample.bin", std::ios::in | std::ios::binary);
    auto res = 
*     s2s::struct_cast<our_struct>(ifs)
          .transform([](const our_struct& fields){
*           std::println("len={} str={}", fields.len, fields.str);
            return fields;
          }).transform_error([](const s2s::cast_error& err){
            std::println("failure_reason={} failed_at={}", static_cast<int>(err.failure_reason), err.failed_at);
            return err;
          });
    return 0;
  }
```
<!-- -------------------- Speaker Notes ------------------- -->
???
- The code partially remains the same, it is possible to 
  access members with regular . operator but leaving out the square bracket
  operator will make it backward compatible. After all we are in C++
  world, backward compatibility is something we strive for
- In near future this should be possible
- I plan to complete this experimental implementation or atleast explore
  it limits by early 2026
---
Link to project: [s2s](https://github.com/hariceratops/s2s)
```cpp
return 0;
```


- GIT:[hariceratops](https://github.com/hariceratops/)
- LINKEDIN:[Hari Prasad](https://www.linkedin.com/in/hari-prasad-manoharan-79a4ba102/)
- MASTODON:@hariceratops@mastodon.social


<!-- -------------------- Speaker Notes ------------------- -->
???
- The godbolt execution doesnt timeout
- Dont be afraid to do a project, even at the cost of failing
- It is fun, you can crash compilers, text editors
- It takes a village
- So I would be happy to collaborate and extend the project

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
    var slideshow = remark.create({
        highlightLines: true
    });
    </script>
  </body>
</html>
