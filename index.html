<!-- https://github.com/gnab/remark/issues/538#issuecomment-419173985 -->
<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Rubik);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700,400italic);

      body { font-family: 'Rubik'; }
      h1 {
        font-family: 'Rubik';
        font-weight: bold;
      }
      h2, h3 {
        font-family: 'Rubik';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Source Code Pro'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Binary Parsing, C++23 Style
### Hari Prasad Manoharan

---
### About Me

```bash
> whoami
USER:hari
COMPANY:mbition
GIT:https://github.com/hariceratops/
LINKEDIN:https://www.linkedin.com/in/hari-prasad-manoharan-79a4ba102/
MASTODON:@hariceratops@mastodon.social
PRIMARY_DOMAIN:embedded_systems
ENGINEER_SINCE:2016_08_16
```
---
### Disclaimer

- I am not an expert, I am just a dude
- The views presented are not of my employer
- Project is not production ready, at least not yet!
- We will walkthrough the simplified version of the project source
???
- I have been developing SW with C++ for past 6 years or so
- The original project is close to 5000 lines and would be not practical 
to go through it in a talk
- But most metaprogramming talks still appear like magic
- So the idea is to skim through the basic version
- This way avoid first you draw circle and next step you end up with an owl
---
### How this came to be?
- Parsing binary format is something any developer would run into at some point
- No declarative way to describe a binary format in C++
- Came across following projects which led to some solid work
  - [CTRE, Hana Dusíková](https://www.youtube.com/watch?v=g51_HYn_CqE&t=1232s)
  - [namedtuple++, Kris Jusiak](https://www.youtube.com/watch?v=4PwNi0Zgmm0)
  - [Value Based Metaprogramming, Kris Jusiak](https://www.youtube.com/watch?v=yriNqhv-oM0)
???
- Too much boiler plate if handwritten, code generation was not appealing
- As a side note, watch talks, attend conferences and meet people
- Thanks to Kris, Hana
---
class: center, middle
# Fact Check!
---
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};
auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance), sizeof(instance));
  std::println("{:X} {:X} {:X}", 
    instance.member_1, 
    instance.member_2, 
    instance.member_3
  );
};
```
```sh
# Input: file.bin
0x000000: 0xef 0xbe 0xad 0xde ....
0x000004: 0x0d 0xd0 0xfe 0xca ....
0x000008: 0xef 0xbe 0xef 0xbe ....
0x00000c:
   bytes: 12
```
--
count: false
```sh
deadbeef cafed00d beefbeef
```
---
```cpp
struct some_thing {
  uint32_t member_1;
* uint8_t member_2;
  uint32_t member_3;
};
auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance), sizeof(instance));
  std::println("{:X} {:X} {:X}", 
    instance.member_1, 
    instance.member_2,
    instance.member_3
  );
};
```
```sh
# Input: file.bin
0x000000: 0xef 0xbe 0xad 0xde ....
*0x000004: 0x2a 0x0d 0xd0 0xfe ....
0x000008: 0xca                ....
0x00000c:
   bytes: 9
```
--
count: false
```sh
deadbeef 2a ca7f
```
---
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};

auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance), sizeof(instance));
  std::println("{:X} {:X} {:X}", 
    instance.member_1, 
    instance.member_2, 
    instance.member_3
  );
};
```
```sh
0x000000: 0xef 0xbe 0xad 0xde ....
*0x000004: 0x42 0x42 0x42 0x0d ....
0x000008: 0xd0 0xfe 0xca      ....
0x00000c:
   bytes: 11
```
--
count: false
```sh
deadbeef d424242 c9cafed0
```
---
Solution
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};

auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance;          
  file.read(reinterpret_cast<char*>(&instance.member_1), sizeof(instance.member_1));
  file.read(reinterpret_cast<char*>(&instance.member_2), 3);
  file.read(reinterpret_cast<char*>(&instance.member_3), sizeof(instance.member_3));
  std::println("{:X} {:X} {:X}", instance.member_1, instance.member_2, instance.member_3);
  file.close();
};
```
---
count: false
```cpp
struct some_thing {
  uint32_t member_1;
  uint32_t member_2;
  uint32_t member_3;
};

auto parse_something(std::ifstream& file) -> some_thing {
  constexpr std::size_t member_1_size = sizeof(instance.member_1);
  constexpr std::size_t member_2_size = 3;
  constexpr std::size_t member_3_size = sizeof(instance.member_3);

  some_thing instance;
  file.read(reinterpret_cast<char*>(&instance.member_1), member_1_size);
  file.read(reinterpret_cast<char*>(&instance.member_2), member_2_size);
  file.read(reinterpret_cast<char*>(&instance.member_3), member_3_size);
  return instance;
}

auto main(void) -> int {
  std::ifstream file("file.bin", std::ios::binary | std::ios::in);
  some_thing instance = parse_something();          
  std::println("{:X} {:X} {:X}",
    instance.member_1, 
    instance.member_2, 
    instance.member_3
  );
  file.close();
};
```
---
Lets throw this to our code
```sh
0x000000: 0xef 0xbe 0xad 0xde ....
0x000004: 0x42 0x42 0x42 0x0d ....
0x000008:                     ....
0x00000c:
   bytes: 8
```
--
count: false
We will have to handle buffer exhaustion now
--
count: false
```cpp
enum parse_error { buffer_exhausted = 0 };
using parse_res = std::expected<some_thing, parse_error>;

auto parse_something(std::ifstream& file) -> parse_res {
  constexpr std::size_t member_1_size = sizeof(instance.member_1);
  constexpr std::size_t member_2_size = 3;
  constexpr std::size_t member_3_size = sizeof(instance.member_3);

  some_thing instance;
  if(!file.read(reinterpret_cast<char*>(&instance.member_1), member_1_size))
    return std::unexpected(parse_error::buffer_exhausted);
  if(!file.read(reinterpret_cast<char*>(&instance.member_2), member_2_size))
    return std::unexpected(parse_error::buffer_exhausted);
  if(!file.read(reinterpret_cast<char*>(&instance.member_3), member_3_size))
    return std::unexpected(parse_error::buffer_exhausted);
  return instance;
}
```
---
```cpp
struct some_thing {
  uint32_t member_1;
  bool member_2;
  // Has to be parsed only if member_2 == true
  uint32_t member_3;
};
```
--
count: false
```cpp
auto parse_something(std::ifstream& file) -> parse_res {
  constexpr std::size_t member_1_size = sizeof(instance.member_1);
  constexpr std::size_t member_2_size = 3;
  constexpr std::size_t member_3_size = sizeof(instance.member_3);

  some_thing instance;
  if(!file.read(reinterpret_cast<char*>(&instance.member_1), member_1_size))
    return std::unexpected(parse_error::buffer_exhausted);
* if(instance.member_2 && !file.read(reinterpret_cast<char*>(&instance.member_2), member_2_size))
    return std::unexpected(parse_error::buffer_exhausted);
  if(!file.read(reinterpret_cast<char*>(&instance.member_3), member_3_size))
    return std::unexpected(parse_error::buffer_exhausted);
  return instance;
}
```
---
class: middle
- Length prefixed vectors
--

count: false
- Unions / TLV
--

count: false
- Endianness
--

count: false
- Validation of Field Values
--

count: false
- Delimited Fields
--

count: false
- Magic Numbers
---
### Or as Dr.Stephan Strange said,
```c 
struct hands {
  char left_hand[4];
  char right_hand[4];
};
hands h{};
strcpy(h.left_hand, "things.....");
printf("%s %s\n", h.left_hand, h.right_hand);
```
---
.center[![dr_strange](./images/dr_strange.gif)]
---
### Possible Solutions
- Custom DSL 
- Rolling out a custom DSL and code generator
- Template Metaprogramming Magic
- &#x1F381
---
.center[![i_like_this](./images/i_like_this.png)]
---
class: center, middle
### &#x26A0 Template Metaprogramming Ahead!
???
- I have had love-hate relationship with TMP
- Whenever I write template typename ..., I get faces, I mean not angry faces, 
but not happy faces
- I do get the sentiment here, they are hard to get right, slower compile times
- But TMP has its place, like our little project
---
class: center, middle
# TMP Primer
---
### Variadic Templates
```cpp
template <typename... Args>
void func(Args... args) {
  auto l = func_a(args...);
  auto k = func_b(func_c(args)...);
}
```
- ... before template parameter pack in the template declaration denotes definition
- ... after template paramter pack in the body of the template denotes expansion
- func(args...) => func(arg_1, arg_2, ..., arg_n)
- func(args)... => func(arg_1), func(arg_2), func(arg_3) ... func(arg_n)
- If you have different sized parameter packs, they shall be of same size
- Parameter packs can be expanded into binary operation using left or right 
fold expression according to required associativity
- An excellent talk by Miro Knejp [... + CTAD + NTTP](https://www.youtube.com/watch?v=Hyuvpv42YM8)
--
count: false

```cpp
template <typename... Args>
struct type_list {};
```
???
- Variadic functions are everywhere. make_unique, make_shared you name it
- Store arbitrary number of types in this placeholder list
- This along with pack manipulation would be one of the central concept for the library
---
### Metafunctions
A function executed in compile time 
- which takes types or values known at compile time as input
- returns types or values known at compile time
- typically implemented with class templates, specializations and using aliases
```
f(T | V_comp_time) => T | V_comp_time
```
--
count: false
Typical example, from the STL
```cpp
template< class T >
using remove_cv_t = typename remove_cv<T>::type;
```
--
count: false
Metafunctions are composable
```cpp
template<class T>
struct remove_cvref {
  using type = std::remove_cv_t<std::remove_reference_t<T>>;
};
```
---
count: false
It is possible to roll out one's own metafunction
```cpp
template <typename T>
struct is_optional_like;

template <typename T>
struct is_optional_like {
  static inline constexpr bool res = false;
};

template <typename T>
struct is_optional_like<std::optional<T>> {
  static inline constexpr bool res = true;
};

template <typename T>
inline constexpr bool is_optional_like_v = is_optional_like<T>::res;

template <typename T>
concept optional_like = is_optional_like_v<T>;
```
???
- One can roll out a function to search a type_list with a predicate
- Sort it
---
class: center, middle
# Lets write our parser
---
### Our Dream [Spoiler - would stay as dream for now &#x1F605]
```
struct_field_list(
  basic_field("a", u32, field_size(fixed(4))),
  basic_field("b", u32, field_size(fixed(4)))
);

struct_field_list(
  basic_field("len", std::size_t, field_size(fixed(8))),
  str_field("str", field_size(len_from_field("len")))
);

struct_field_list(
  basic_field("a", u32, field_size(fixed(4))),
  basic_field("b", u32, field_size(fixed(4))),
  variance(
    "c",
    type(
      match_field("a"),
      type_switch(
        match_case(0xcafed00d, as_struct(inner_1)),
        match_case(0xdeadbeef, as_struct(inner_2))
      )
    )
  )
);
```
---
### Reality
```cpp
* s2s::struct_field_list<
*  s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>,
*  s2s::basic_field<"b", u32, s2s::field_size<s2s::fixed<4>>>
* >;

* s2s::struct_field_list<
*  s2s::basic_field<"len", std::size_t, s2s::field_size<s2s::fixed<8>>>,
*  s2s::str_field<"str", s2s::field_size<s2s::len_from_field<"len">>>
* >;

s2s::struct_field_list<
  s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>,
  s2s::basic_field<"b", u32, s2s::field_size<s2s::fixed<4>>>,
  s2s::variance<
    "c",
    s2s::type<
      s2s::match_field<"a">,
      s2s::type_switch<
        s2s::match_case<0xcafed00d, s2s::as_struct<inner_1>>,
        s2s::match_case<0xdeadbeef, s2s::as_struct<inner_2>>
      >
    >
  >
>;
```
---
class: center, middle

```cpp
s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>
```
???
- A fixed compile time string as field named
- The type of the field
- A size hint
---
### Construct for string template arguments
```cpp
template <std::size_t N>
struct fixed_string {
  std::array<char, N + 1> value;
  constexpr fixed_string(): value{} {};
  constexpr fixed_string(const char (&str)[N + 1]) {
    std::copy_n(str, N + 1, value.data());
  }
  constexpr const char* data() const { return value.data(); }
  constexpr char* data() { return value.data(); }
  constexpr std::size_t size() const { return N; }
  constexpr auto to_sv() -> std::string_view const {
    return std::string_view{data()};
  }
};

template <std::size_t N>
fixed_string(const char (&)[N]) -> fixed_string<N - 1>;

template <std::size_t N1, std::size_t N2>
constexpr bool operator==(fixed_string<N1> lhs, fixed_string<N2> rhs) {
  if constexpr(N1 != N2) return false;
  return std::string_view{lhs.data()} == std::string_view{rhs.data()};
}
```
---
### Literals for accessing our fields
```cpp
template <fixed_string id>
struct field_accessor {
  static constexpr auto field_id = id;
};


namespace s2s_literals {
template <fixed_string id>
constexpr auto operator""_f() {
  return field_accessor<id>{};
}
}
```
--
count: false
Now we can do this,
```cpp
// if a hypotheical type supports a square bracket 
// operator with field_accessor as input argument 
fields["hello"_f];
```
---
### Denoting sizes
```cpp
template <typename size_type>
struct field_size {
  using size_type_t = size_type;
};

template <std::size_t N>
struct fixed {
  static constexpr auto count = N;
};

template <fixed_string id>
using len_from_field = field_accessor<id>;
```
---
We can denote
--
count: false
- Name &#x2705
--
count: false
- Size &#x2705
--
count: false
- Type &#x2705
--
count: false

```cpp
template <
  fixed_string id, 
  typename T, 
  typename size_type
>
struct field {
  using field_type = T;
  using field_size = size_type;

  static constexpr auto field_id = id;
  field_type value{};
};
```
--
count: false
```cpp
s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>> &#x2705
```
---
class: middle
```cpp
s2s::struct_field_list<
  s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>,
  s2s::basic_field<"b", u32, s2s::field_size<s2s::fixed<4>>>
>;
```
---
count: false
### Struct
```cpp
template <typename... fields>
  requires are_unique_fields_v<fields...> && size_dependencies_resolved_v<fields...>
struct struct_field_list : fields... {
  template <typename field_accessor,
            typename field = field_lookup_v<
              type_list<fields...>, 
              field_accessor::field_id>
            >
    requires (!std::is_same_v<field_lookup_failed, field>)
  constexpr auto& operator[](field_accessor)  {
    return static_cast<field&>(*this).value;
  }

  template <typename field_accessor,
            typename field = field_lookup_v<
              type_list<fields...>, 
              field_accessor::field_id>
    requires (!std::is_same_v<field_lookup_failed, field>)
  constexpr const auto& operator[](field_accessor) const {
    return static_cast<const field&>(*this).value;
  }
};
```
???
- Requires are_unique_fields_v<fields...> && size_dependencies_resolved_v<fields...>
- Will skip the complete walkthrough for are_unique_fields_v and size_dependencies_resolved_v
- They are metafunctions to 
  - check if there are no repetition in field names 
  - if a field depends on another field for its size, then the dependency occurs strictly to left
---
### How the accessor[] works here?
Static casting the "struct" which is inherited from multiple fields to one valid field, 
leads to object slicing and only the base field from which struct was inherited is returned by reference
.center[![valid_cast](./images/cast_valid_object_slicing.png)]
---
count: false
.center[![invalid_cast](./images/cast_invalid_object_slicing.png)]

```sh
<source>:33:24: error: no viable overloaded operator[] for type 's2s::struct_field_list_impl<2UL, s2s::field<fixed_string<2UL - 1>{{"a"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>, s2s::field<fixed_string<2UL - 1>{{"b"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>> const'
   33 |     std::cout << fields["e"_f] << fields["b"_f];
      |                  ~~~~~~^~~~~~
/app/raw.githubusercontent.com/hariceratops/s2s/main/single_header/s2s.hpp:2181:19: note: candidate function template not viable: 'this' argument has type 's2s::struct_field_list_impl<2UL, s2s::field<fixed_string<2UL - 1>{{"a"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>, s2s::field<fixed_string<2UL - 1>{{"b"}}, unsigned int, s2s::field_size<s2s::fixed<4>>, no_constraint<u32>{}>> const', but method is not marked const
 2181 |   constexpr auto& operator[](field_accessor)  {
      |                   ^
/app/raw.githubusercontent.com/hariceratops/s2s/main/single_header/s2s.hpp:2191:25: note: candidate template ignored: constraints not satisfied [with field_accessor = s2s::field_accessor<s2s::fixed_string<2UL - 1>{{"e"}}>, field_lookup_res = static_optional<field_type_info>{{0, 0}, false}]
 2191 |   constexpr const auto& operator[](field_accessor) const {
      |                         ^
/app/raw.githubusercontent.com/hariceratops/s2s/main/single_header/s2s.hpp:2190:15: note: because 'static_optional<field_type_info>{{0, 0}, false}.has_value' evaluated to false
 2190 |     requires (!std::is_same_v<field_lookup_failed, field>)
      |
```
???
- Not the prettiest error message, this is as good as it gets
- In fact clang does a great job with being succtinct
---
### How does the lookup work?
```cpp
struct field_lookup_failed {};

template <typename ls, fixed_string id>
struct field_lookup;

template <fixed_string id>
struct field_lookup<type_list<>, id> {
  using type = field_lookup_failed;
};
template <fixed_string id, typename T, std::size_t size, typename... rest>
struct field_lookup<type_list<field<id, T, size>, rest...>, id> {
  using type = field<id, T, size>;
};

template <fixed_string id, typename head, typename... rest>
struct field_lookup<type_list<head, rest...>, id> {
  using type = typename field_lookup<field_list<rest...>, id>::type;
};

template <typename list, fixed_string id>
using field_lookup_v = typename field_lookup<list, id>::type;
```
???
- If we have exhausted the list, we have not found the field we are 
trying access in the struct
- Since the names are ensured to be unique, it is guaranteed we will have just one hit for our field
---
### How uniqueness and dependencies are guaranteed
##&#x1F44B
---
class: middle
```cpp
s2s::struct_field_list<
  s2s::basic_field<"a", u32, s2s::field_size<s2s::fixed<4>>>,
  s2s::basic_field<"b", u32, s2s::field_size<s2s::fixed<4>>>
>;
```
&#x2705
---
### Errors
```cpp
enum error_reason {
  buffer_exhaustion,
  validation_failure,
  type_deduction_failure
};


struct cast_error {
  error_reason failure_reason;
  std::string_view failed_at;
};


using rw_result = std::expected<void, error_reason>;
using cast_result = std::expected<void, cast_error>;
```
---
```cpp
char* byte_addressof(T& obj) {
  return reinterpret_cast<char*>(&obj);
}

template <typename T, std::size_t N>
char* byte_addressof(std::array<T, N>& obj) {
  return reinterpret_cast<char*>(obj.data());
}

/* other overloads */
// todo size deduction utilities
```
---
### We read atlast
```cpp
template <typename... args>
struct struct_cast_impl;

template <typename... fields, typename stream, auto endianness>
struct struct_cast_impl<struct_field_list<fields...>, stream, endianness> {
  using S = struct_field_list<fields...>;
  using R = std::expected<S, cast_error>;

  constexpr auto operator()(stream& s) -> R {
    S field_list;
    cast_result pipeline_seed{};
    auto res = (
      pipeline_seed |
      ... |
      [&]() -> cast_result {
        auto& field = static_cast<fields&>(field_list);
        // Some read magic here &#x1FA84
        return {};
      }
    );
    return res ? R(field_list) : std::unexpected(res.error());
  }
};
```
???
- Short circuit the remaining pipeline since read failed for current field
---
```cpp
bool read_res = false;
if constexpr (is_struct_field_list_v<extract_type_from_field_v<fields>>) {
  using inner_struct = extract_type_from_field_v<fields>>;
  auto field_value = struct_cast<inner_struct>(ifs);
  if(!field_value)  
    return std::unexpected(field_value.error());
} else if constexpr (is_comptime_sized_field_v<fields>) {
  // constexpr auto read_size = field_size::size_type_t::count;
  read_res = ifs.read(byte_addressof(field.value), read_size);
} else if constexpr (is_runtime_sized_field_v<fields>) {
  constexpr auto len_to_read = deduce_field_size<field_size>{}(input);
  constexpr auto read_size = len_to_read * sizeof(field.value);
  read_res = ifs.read(byte_addressof(field.value), read_size);
}

if(!read_res) /* ... */
```
---
Cast
---
Field Descriptors
---
### Et viola
```cpp
  #include "s2s.hpp"
  #include <print>

  using namespace s2s_literals;

  auto main(void) -> int {
*   using our_struct = 
*     s2s::struct_field_list<
*       s2s::basic_field<"len", std::size_t, s2s::field_size<s2s::fixed<8>>>,
*       s2s::str_field<"str", s2s::field_size<s2s::len_from_field<"len">>>
*     >;
    std::ifstream ifs("sample.bin", std::ios::in | std::ios::binary);
    auto res = 
*     s2s::struct_cast_le<our_struct>(ifs)
          .transform([](const our_struct& fields){
            std::println("len={} str={}", fields["len"_f], fields["str"_f]);
            return fields;
          }).transform_error([](const s2s::cast_error& err){
            std::println("failure_reason={} failed_at={}", static_cast<int>(err.failure_reason), err.failed_at);
            return err;
          });
    return 0;
  }
```
---
### Benchmarks
todo
---
### &#x1F381 = Reflection
todo
---
Link to project: [s2s](https://github.com/hariceratops/s2s)
```cpp
return 0;
```
???
- Dont be afraid to do a project, even at the cost of failing
- It takes a village

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
    var slideshow = remark.create({
        highlightLines: true
    });
    </script>
  </body>
</html>
